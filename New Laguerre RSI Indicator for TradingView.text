//@version=4
// Copyright (c) 2021-present, Alex Orekhov (everget)
strategy("HalfTrend", overlay=true)



signal_length = input(11)
sma_signal = true 

lin_reg = true
linreg_length = input(11)

bopen = lin_reg ? linreg(open, linreg_length, 0) : open
bhigh = lin_reg ? linreg(high, linreg_length, 0) : high
blow = lin_reg ? linreg(low, linreg_length, 0) : low
bclose = lin_reg ? linreg(close, linreg_length, 0) : close


length = input(14)
OverBought = input(80)
OverSold = input(20)
smoothK = 3
smoothD = 3
k = sma(stoch(bclose, bhigh, blow, length), smoothK)
d = sma(k, smoothD)


pine_ema(src, length) =>
    alpha = 2 / (length + 1)
    sum = 0.0
    sum := na(sum[1]) ? 
         src : 
         alpha * src + (1 - alpha) * nz(sum[1])

calculateSignals(amplitude, channelDeviation, showArrows, showChannels) =>
    var int trend = 0
    var int nextTrend = 0
    var float maxLowPrice = nz(low[1], low)
    var float minHighPrice = nz(high[1], high)

    var float up = 0.0
    var float down = 0.0
    float atrHigh = 0.0
    float atrLow = 0.0
    float arrowUp = na
    float arrowDown = na

    atr2 = atr(input(300)) / 2
    dev = channelDeviation * atr2

    highPrice = high[abs(highestbars(amplitude))]
    lowPrice = low[abs(lowestbars(amplitude))]
    highma =  sma(high, amplitude)
    lowma =   sma(low, amplitude)

    if nextTrend == 1
        maxLowPrice := max(lowPrice, maxLowPrice)

        if highma < maxLowPrice and close < nz(low[1], low)
            trend := 1
            nextTrend := 0
            minHighPrice := highPrice
    else
        minHighPrice := min(highPrice, minHighPrice)

        if lowma > minHighPrice and close > nz(high[1], high)
            trend := 0
            nextTrend := 1
            maxLowPrice := lowPrice

    if trend == 0
        if not na(trend[1]) and trend[1] != 0
            up := na(down[1]) ? down : down[1]
            arrowUp := up - atr2
        else
            up := na(up[1]) ? maxLowPrice : max(maxLowPrice, up[1])
        atrHigh := up + dev
        atrLow := up - dev
    else
        if not na(trend[1]) and trend[1] != 1 
            down := na(up[1]) ? up : up[1]
            arrowDown := down + atr2
        else
            down := na(down[1]) ? minHighPrice : min(minHighPrice, down[1])
        atrHigh := down + dev
        atrLow := down - dev

    ht = trend == 0 ? up : down
    
    
    g = k >= OverBought and d >= OverBought
    v = k <= OverSold and d <= OverSold

    // Modify buySignal and sellSignal conditions to include overbought and oversold conditions
    buySignal = not na(arrowUp) and (trend == 0 and trend[1] == 1) and g
    sellSignal = not na(arrowDown) and (trend == 1 and trend[1] == 0) and v

    [buySignal,sellSignal]

// Call the 
a = input(25)
b = input(19)
[buySignal, sellSignal] = calculateSignals(a, 2, true, true)

[buySignal1, sellSignal1] = calculateSignals(b, 2, true, true)


stopLevel = input(36)

if (sellSignal)
    strategy.entry('Buy', strategy.long)
    strategy.exit('Exit Buy', 'Buy', stop=low - stopLevel * syminfo.mintick)

if (buySignal1)
    strategy.entry('Sell', strategy.short)
    strategy.exit('Exit Sell', 'Sell', stop=high + stopLevel * syminfo.mintick)
