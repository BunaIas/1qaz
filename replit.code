const { DateTime } = require('luxon');
const now = DateTime.now().setZone('Europe/Bucharest');
let currentHour = now.hour;
let banana = now.minute;
let  gmt = now.offset;
if(gmt == 180){gmt = 3}
else {gmt = 2}
let babylon = now.weekdayShort;
const Database = require('@replit/database')
const db = new Database()

const express = require('express')
const server = express()
server.all("/", (req, res) =>{res.send("bot is running")
                             })

async function KeepAlive() {

  server.listen(3000, () =>{
    console.log("server is ready")
  })
}
KeepAlive();


console.log(currentHour+':'+banana);

async function a(){ 
//await delete_();
if(await db.get("ai") !== null){
  console.log("remaining things to do:");
  let aii = await db.get("ai");
  let aee = await db.get("ae");
  const   numbersi = await db.get("numbers")
  const   past_day = await db.get("past_day");
let  current_day = now.toISODate();
let rampollo_banana = now.toFormat('HH:mm');
  
for(let greedy = 0; greedy < numbersi.length; greedy++){
  
    if( current_day == past_day && rampollo_banana < numbersi[greedy] )
     { let startTime =  numbersi[greedy].split(':');
       await jobe(startTime[1],startTime[0],hours(aii[greedy],aee[greedy]))        
     }
}          
 await delete_();
 await delete_();
 console.log("keys are deleted");
}

if(currentHour == 1 && babylon !== 'Satu' && babylon !== 'Sunu')
{ await jobi() }
else { await BingBang() }
}
a();


const g = 'tret';
console.log(g[2]+"ururur");
const e = "aeru";
const xi = now.toISODate();
console.log(xi);


const { Octokit } = require("@octokit/rest");
const octokit = new Octokit({
      auth: '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'
    });
async function r(y) {
  try {   
    await octokit.request('POST /repos/{owner}/{repo}/dispatches', {
      owner: 'BunaIas',
      repo: '1qaz',
      event_type: 'start-workflow',
      client_payload: {
         my_constant: y,
      }
    });

    console.log("Workflow triggered successfully.");
  } catch (error) {
    console.error("Failed to trigger workflow:", error);
  }  
}


async function circle(x){
let fileSha;
await octokit.repos.getContent({
  owner: 'BunaIas',
  repo: '1qaz',
  path: '.circleci/custom_string.txt'
}).then(response => {
 fileSha = response.data.sha;
  //console.log(response.data.sha)
})
  
let something = Buffer.from(x).toString('base64');
try{
 await octokit.request('PUT /repos/{owner}/{repo}/contents/{path}', {
  owner: 'BunaIas',
  repo: '1qaz',
  path: '.circleci/custom_string.txt',
  message: 'my commit message',
  committer: {
    name: 'Monalisa Octocat',
    email: 'octocat@github.com'
  },
  content: something,
  headers: {
    'X-GitHub-Api-Version': '2022-11-28'
  },
  sha: fileSha
  })

console.log('circle start')
 }catch (error) {
    console.error("Failed to trigger workflow:", error);
  }  
}




function hours(x,y){
let end = [];
end.push(x)
//console.log(xi+' | '+x+' | '+stormTime(end, 1)+' | '+gmt+'  '+'['+y+']');
console.log(xi+' | '+x+' | '+stormTime(end, 1)+' | '+gmt+' '+y)
return xi+' | '+x+' | '+stormTime(end, 1)+' | '+gmt+' '+y;
}


const CronJob = require('cron').CronJob;

function jobe(x,a,y) {
let coconut = now.toFormat('HH:mm'); 
if(coconut < a+':'+x){
  
  return new Promise((resolve, reject) => {
    const joba = new CronJob('40 '+x+' '+a+' * * *', async  function(){
     await r(y);
     await circle(y);
    // console.log(383838383);
     await joba.stop();
     console.log("joba has stopped")
      
  resolve();
      }, null, true, 'Europe/Bucharest');
  });
                    }  
}


async function jobi(){
let [ai,ae] = await take_that_away_put_the_knife_down_Maurice_get_the_damn_laxatives_he_did_it_again();
  //  console.log(ai,ae);
  //  ai = [];
  //  ae = [];
    let numbers = stormTime(ai ,-2)
    reluare(numbers,ai,ae);
    console.log('length is '+numbers.length);
    for (let j = 0; j < numbers.length; j++) {
      let startTime = numbers[j].split(':');
      await jobe(startTime[1] , startTime[0] , hours(ai[j],ae[j]) );
    }
await delete_();
await delete_();
console.log("keys are deleted")
await BingBang(); 
}


function stormTime(nave,cannonballs){
let shipwhrek = [];
for (let mangoose = 0; mangoose < nave.length; mangoose++){
  
const battle = DateTime.fromFormat(nave[mangoose], 'HH:mm');
let asse = battle.plus({ minutes: cannonballs });
shipwhrek.push(asse.toFormat('HH:mm'));
   }
return shipwhrek;
}


const morse = require('morse');
async function BingBang() {
console.log('\x1b[38;5;208m%s\x1b[0m',morse.decode('-')+morse.decode('.... .- -').toLowerCase()+"'"+morse.decode('...').toLowerCase()+' '+morse.decode('.-')+morse.decode('.-.. .-..').toLowerCase()+' '+morse.decode('..-.')+morse.decode('--- .-.. -.- ...').toLowerCase());
    
     setTimeout(() => {
     process.exit(5);
    }, 4000);

  }


async function reluare(x,ai,ae){
await db.set("ai",ai);
await db.set("ae",ae);
await db.set("length",x.length);
await db.set("numbers",x); 
await db.set("past_day",xi); 
} 


async function delete_(){
await db.delete("ai");  
await db.delete("ae");
await db.delete("numbers");
await db.delete("length");
await db.delete("past_day");
}



////////////////////////////////////////////////////////////////////////////////////////////////////////
async function take_that_away_put_the_knife_down_Maurice_get_the_damn_laxatives_he_did_it_again(){

  
const { gotScraping } = require('got-scraping');
const cheerio = require('cheerio');
let the_cold_and_billowing_sea = now.toISODate();
let gmt2 = now.offset; 

  
async function white(){
 return new Promise((resolve, reject) => {
gotScraping
  .get('https://tradingeconomics.com/calendar', {
    headers: {
       'Cookie': 'calendar-countries=aus,can,emu,eun,fra,deu,ita,jpn,esp,gbr,usa,wld,opc,aut,bel,fin,grc,irl,nld,nzl,prt,swe,che,isl; calendar-importance=1; cal-custom-range='+ the_cold_and_billowing_sea+'|'+the_cold_and_billowing_sea+'; cal-timezone-offset='+gmt2+'; _gat=1',
    }
  })
  .then(({ body }) => {
    let $ = cheerio.load(body);
    
const the_first_string = ['0','1', '2', '3','4','5','6','7','8','9','A','P','M',':'];
const uii = ['0','1', '2', '3','4','5','6','7','8','9','.','-'];
function extrage(x,y){
let garling = 0;
let m = '';
while (garling <= x.length){
  
if( y == 0 ){
  if (the_first_string.includes(x[garling])) {
     m = m + x[garling];                     }
            } 
else {
  if (uii.includes(x[garling])) {
     m = m + x[garling];        }
     }
  
     garling++;
                         }
    return m 
  } 
    
function change_the_hour_format_because_god_forbid_to_have_normal_hours_but_still_tanks_for_the_data(x){
  if(x.slice(5) == 'AM' && x.slice(0,2) == '12' ){ x = '00' + x.slice(2,5); return x }
  else {
if(x.slice(5) == 'PM' && x.slice(0,2) !== '12'){
  x = 12 + parseFloat(x.slice(0,2))  + x.slice(2)
    return x.slice(0,5)
}
else {return x.slice(0,5) }  
  }
 } 
    
let u = ['white_prev'];
let f = ['white_old_prev'];
let mad = ['white_event'];
let old_mad = ['old_white_event'];
for (let i =0; i<=  $('tbody').eq(1).find('span#previous').length-1; i++  ){
  
let econ_ore =  $('tbody').eq(1).find('tr').eq(i*2).find('td').eq(0).text();
let econ_prev = $('tbody').eq(1).find('span#previous').eq(i).text();
let old_prev_econ = $('tbody').eq(1).find('tr').eq(i*2).find('span#revised').attr('title');
let Chicken = $('tbody').eq(1).find('tr').eq(i*2).attr('data-id');

  
econ_ore = change_the_hour_format_because_god_forbid_to_have_normal_hours_but_still_tanks_for_the_data(extrage(econ_ore,0));

econ_prev = extrage(econ_prev,1);

if (old_prev_econ){
 old_prev_econ = extrage(old_prev_econ,1); }

  if(econ_ore && econ_prev){
      u.push(econ_ore+' , '+parseFloat(econ_prev));  mad.push(Chicken) }


    if(econ_ore && old_prev_econ){
      f.push(econ_ore+' , '+parseFloat(econ_prev) ,econ_ore+' , '+parseFloat(old_prev_econ));   old_mad.push(Chicken , Chicken)}
  
  } 

   //console.log(u,f,td_prev,td_old,mad,old_mad)
   resolve([u,f,mad,old_mad]);
})
   
   })
  .catch((err) => {
    console.error(err);
  });
}

async function black(){
 return new Promise((resolve, reject) => {
gotScraping 
  .get('https://www.investing.com/economic-calendar/', {
    headers: { 'Cookie':'__cflb=02DiuGRugds2TUWHMkkPGro65dgYiP187kAAnRspffCFW;ses_id=ZSs%2FfjI9MDg%2Fe25oMmM2MDFhM2tmZGdiZWVjYjo0b3k5LTM9NWJhJzc4OXdkZ2V5NTI1Yz9gMzUzZmVgOjpnYGUxP2syZDBsPzpuYzJiNjcxMjM6ZjNnY2VmYzY6NW8wOTYzZjUzYTA3YTljZG5lbjUnNSk%2FezMiM2FlNTp7ZyBlaj9%2BMmIwaD9qbmEyNTZmMWQzaWZpZ2RlMmM2OjRvdzly; ',
//when hours is chenging go to inv account and change the hour because this cookies uses the timezone of the account
    } 
  })

  .then(({ body }) => {
    const $ = cheerio.load(body);

const the_zero_plus_two_string = ['0','1', '2', '3','4','5','6','7','8','9','-','.',':'];
function extrage(x){
let garling = 0;
let m = '';
while (garling <= x.length){

  if (the_zero_plus_two_string.includes(x[garling])) {
     m = m+ x[garling];

       }
  garling++;
    }
    return m
}
let z = ['black_prev'];
let t = ['black_old_prev'];
let td_prev = ['td_prev'];
let td_old = ['td_old'];
let name_currency = ['name_currency'];
let forecast = ['forecast'];
let links = ['links'];
let mad = ['black_event'];
let old_mad = ['black_old_event'];
for( let i = 0; i<=  $('tbody').eq(2).find('tr').length-1 ; i++ ){

let inv_ore =  $('tbody').eq(2).find('tr').eq(i).find('td').eq(0).text();
let inv_star =  $('tbody').eq(2).find('tr').eq(i).find('td').eq(2).attr('data-img_key');
let inv_prev = extrage($('tbody').eq(2).find('tr').eq(i).find('td').eq(6).text());
let old_prev_inv= $('tbody').eq(2).find('tr').eq(i).find('td').eq(6).find('span').attr('title');
let viso = $('tbody').eq(2).find('tr').eq(i).find('td').eq(3).text().trim();
let currency = $('tbody').eq(2).find('tr').eq(i).find('td').eq(1).text().trim();
let fore = extrage($('tbody').eq(2).find('tr').eq(i).find('td').eq(5).text().trim());
let tartaruga = $('tbody').eq(2).find('tr').eq(i).find('td').eq(3).find('td.left.event a').attr('href');
let Chicken = $('tbody').eq(2).find('tr').eq(i).attr('id');

  
  if (old_prev_inv){
 old_prev_inv = extrage(old_prev_inv); }

  
  if(inv_prev){
       z.push(inv_star+' , '+inv_ore+' , '+parseFloat(inv_prev) ); td_prev.push(viso); name_currency.push(currency); forecast.push(parseFloat(fore)); links.push(tartaruga); mad.push(Chicken.slice(11)) }

   if(old_prev_inv){
    t.push(inv_star+' , '+inv_ore+' , '+parseFloat(inv_prev) , inv_star+' , '+inv_ore+' , '+parseFloat(old_prev_inv)) ; td_old.push( viso+' || ', viso+' || ' );  old_mad.push(Chicken.slice(11) , Chicken.slice(11)); }

    }
    //console.log(z,t,td_prev,td_old,name_currency,forecast,links,mad,old_mad)  
    resolve([z,t,td_prev,td_old,name_currency,forecast,links,mad,old_mad]);
  
      })
    
  })
  .catch((err) => {
    console.error(err);
  });
}


async function check(white_prev , white_old_prev, white_event ,white_old_event, black_prev, black_old_prev,td_black_prev,td_black_old , name_currency_black , forecast_black , links_black , black_event , black_old_event,  x){

let f = [];

black_prev = black_prev.map( (e,index) => { if(index == 0){return e} else {return e.slice(8)}  })
  
black_old_prev = black_old_prev.map( (e,index) => { if(index == 0){return e} else {return e.slice(8)}  })
  
let white_old2 = []; 
white_old_prev.map( (e,index) => { if(index % 2 == 0){white_old2.push(e)}  })  

let black_old2 =[];
 black_old_prev.map( (e,index) => { if(index % 2 == 0){black_old2.push(e)}  })

 
let _x = dupliquer3(x);
let _white_prev = dupliquer3(white_prev);
let _white_old2 = dupliquer3(white_old2);
let _white_prev_AND_white_old2 = dupliquer3(white_prev,white_old2);
let _black_prev = dupliquer3(black_prev);
let _black_old2 = dupliquer3(black_old2); 
let _black_prev_AND_black_old2 = dupliquer3(black_prev,black_old2);


let fisherman = black_prev;
let fish = black_event;
for(let i = 0; i < x.length; i++){

let moon = '?';
let imagination = '¿';
  
if(!_x.includes(x[i]) && !_white_prev.includes(x[i]) && !_white_old2.includes(x[i]) && !_white_prev_AND_white_old2.includes(x[i])){  
  
  moon = check_white(white_prev , white_old_prev, white_event ,white_old_event, black_prev, black_old_prev , td_black_prev,td_black_old, name_currency_black, forecast_black ,links_black, black_event, black_old_event, x[i] )
  }

 if(!_x.includes(x[i]) && !_black_prev.includes(x[i]) && !_black_old2.includes(x[i]) && !_black_prev_AND_black_old2.includes(x[i])){
   
  imagination = check_black(white_prev , white_old_prev, white_event ,white_old_event, black_prev, black_old_prev , td_black_prev,td_black_old, name_currency_black, forecast_black ,links_black, black_event, black_old_event,x[i] )
  }


if(imagination == '¿'){
  let pain = fisherman.indexOf(x[i]);
  let belevir = fish[pain];
  imagination = belevir+' fiv inv';
  fisherman = fisherman.filter((e,index) => {if(index !== pain){return e} })
  fish = fish.filter((e,index) => {if(index !== pain){return e} })
}

  
let unicorn = moon+' x '+imagination; 
if(unicorn.includes('eco') || unicorn.includes('inv') )
  { f.push(unicorn) }
else { f.push('is just water falling from the sky not lava')}

}
//console.log(f.length,f)
  return f
}

function check_white(white_prev , white_old_prev,white_event,white_old_event ,black_prev, black_old_prev , td_black_prev,td_black_old , name_currency_black, forecast_black ,links_black, black_event ,black_old_event, x){
let f;
if (white_prev.includes(x))
 { let td_serpent = white_prev.indexOf(x);
   td_serpent = white_event[td_serpent];
   f = td_serpent+' new eco';
 }
else if(white_old_prev.includes(x))
 { let td_gallows = white_old_prev.indexOf(x);
   td_gallows = white_old_event[td_gallows];
   f = td_gallows+' old eco';
 }
else if(black_old_prev.includes(x))
 { let m = black_old_prev.indexOf(x);
   m = black_old_prev[m+1];
  
  if(white_prev.includes(m)) 
    { let td_charbon = white_prev.indexOf(m);
      td_charbon = white_event[td_charbon];
      f = td_charbon+x+' new eco' 
    }
  else { f = '?' }
  } 
else { f = '?' }
//console.log(f)
  return f;
}

function check_black(white_prev , white_old_prev,white_event,white_old_event ,black_prev, black_old_prev , td_black_prev,td_black_old , name_currency_black, forecast_black ,links_black, black_event ,black_old_event, x){
let f;
if(black_prev.includes(x))
  { let td_bat = black_prev.indexOf(x)
    td_bat = black_event[td_bat];
    f = td_bat+' nor inv'; 
  }     
else if(black_old_prev.includes(x))
  { let td_abeille = black_old_prev.indexOf(x);
    td_abeille = black_old_event[td_abeille];
    f = td_abeille+' old inv';
  }            
else if(white_old_prev.includes(x))
 { let m = white_old_prev.indexOf(x);
   m = white_old_prev[m+1];
  
  if(black_prev.includes(m)) 
    { let td_riccio = black_prev.indexOf(m);
      td_riccio = black_event[td_riccio];
      f = td_riccio+' new inv'; 
    }
  else { f = '¿' }
  } 
else { f = '¿' }
//console.log(f)
  return f;
}


function dupliquer3(z,zorro){
let tornado;
if (!zorro){ tornado = z.filter((sword, index) => z.indexOf(sword) !== index); }
else { tornado = z.filter((mask) => zorro.includes(mask)); }
//console.log(tornado)
return tornado; 
}


async function black_links(rose,y){
let drink_whith = y.split('-');
let the_living_dead = parseFloat(drink_whith[drink_whith.length-1]);
  
return new Promise((resolve, reject) => {
gotScraping 
  .post('https://www.investing.com/economic-calendar/more-history', {
headers: { 
  'Referer': 'https://www.investing.com'+y,
  'X-Requested-With': 'XMLHttpRequest'
         },
form: {
  eventID: 472960,
  event_attr_ID: the_living_dead,
  event_timestamp: rose+' 08:00:00',
  is_speech: 0
      }
  })
  .then(({ body }) => {
let promise = body.split("event_attr_ID=");

let history;
if(body.includes('"hasMoreHistory":"1"'))
{history = 'MoreHistory'}
else if(body.includes('"hasMoreHistory":false'))
{history = 'NoMoreHistory';}
  
let bones;  
for(let land = 1; land < promise.length; land++){
  
if(promise[land].includes('Better Than Expected')){
  let eyes = promise[land].split('Better Than Expected\\">');
  let revolution = parseFloat(eyes[1].slice(0,10));
  let reload = eyes[1].split('\\"noWrap\\">');
  let sails = parseFloat(reload[1].slice(0,10));
  if(revolution > sails){ bones = 'normal' }
  else if(revolution < sails){bones = 'backwards'}
                                                  }

if(promise[land].includes('Worse Than Expected')){
  let eyes = promise[land].split('Worse Than Expected\\">');
  let revolution = parseFloat(eyes[1].slice(0,10));
  let reload = eyes[1].split('\\"noWrap\\">');
  let sails = parseFloat(reload[1].slice(0,10));
  if(revolution < sails){ bones = 'normal' }
  else if(revolution > sails){ bones = 'backwards'}
                                                 }
  
if(bones == 'normal' || bones == 'backwards'){break}                                           
  } 
    
tattoo = promise[promise.length-1].split('event_timestamp=\\"');
rose = tattoo[1].slice(0,10);
    
   //console.log(rose,bones,history)
   resolve([rose,bones,history]);
      }) 
   })
} 

async function theogony(chaos){
let kraken = [];
for(let Nu = 0; Nu < chaos.length; Nu++){
  let [past,future,history] = await black_links(xi,chaos[Nu]);
  while(future == undefined && history == 'MoreHistory'){
     [past,future,history] = await black_links(past,chaos[Nu]);
  }
if(future == undefined && history == 'NoMoreHistory' )
{future = 'normal'}
kraken.push(future);
}
//console.log(kraken)
return kraken;
}


function rimuovere_le_mele_marce(morning_star,raphael,petru,cactus){
if(cactus !== undefined)
  { let a = [];
    let b = [];
    let c = [];
    let d = [];
    for(let i = 0; i < morning_star.length; i++){
      if(!isNaN(raphael[i])){
        a.push(morning_star[i]);
        b.push(raphael[i]);
        c.push(petru[i]);
        d.push(cactus[i]);
      }
    }
//console.log(a,b,c);
return [a,b,c,d]
 }
else {let polar_bear = ['USD','GBP','EUR','CAD','AUD','NZD','JPY','SEK','CHF'];
      let narwhal = raphael.map(e => {let left_canine = e[0].split(' x '); return left_canine[1]} );
      let whales = [];
      let orcas = [];
      for(let predators = 0; predators < morning_star.length; predators++){

        if(morning_star[predators] !== morning_star[predators+1])
        { whales.push(morning_star[predators]);
          orcas.push(raphael[predators]);
        }
          
      else{let sea_bunny = predators;
           let ancestors = [];
           let sauropod = morning_star[sea_bunny];
           while(morning_star[sea_bunny] == sauropod){
             
             let ursavus = narwhal[sea_bunny];
             let spectacled_bear = polar_bear.indexOf(ursavus);
             ancestors.push(spectacled_bear)
             sea_bunny++;
             }
           
           let pakicetus = Math.min(...ancestors);
           let quetzalcoatlus = ancestors.indexOf(pakicetus)+predators;
           whales.push(morning_star[quetzalcoatlus]);
           orcas.push(raphael[quetzalcoatlus]);
           predators = sea_bunny-1;
         }  
           
      }
    
return [whales,orcas];
    }
}


  
async function titanomachy(uranus,titans,gaia,tartarus,imprisoned){
let hecatonchires = await theogony(imprisoned)
const cronos = uranus.split(' , ');
let zeus = cronos[0];
let gods = [];
for (let fight = 0; fight < titans.length; fight++){

gods.push('  x '+hecatonchires[fight]+' x '+zeus+' x '+cronos[1]+' x '+titans[fight]+' x '+gaia[fight]+' x '+tartarus[fight]+' ||')
} 
  
tartarus =  cronos[1];
titans = [];
titans.push(tartarus)
  
//console.log(titans,gods)
return [ tartarus, gods]
}

  

function you(I){
let c = 0;
for (let i =0; i < I.length; i++){
  let a = I[i].split(' , ');
  
  if (a[0] == 'bull1' && a[1] !== 'NaN'
     ){
c++
  }
  if (a[0] == 'bull2' && a[1] !== 'NaN'
     ){
c++
  }
 if (a[0] == 'bull3' && a[1] !== 'NaN'
     ){
c++
  }
}
if(c>=1){
  return true;
}
  else{return false}
}


async function lucifer(){
let [white_prev , white_old_prev,white_event,white_old_event] = await white();
let [black_prev, black_old_prev, td_black_prev, td_black_old, name_currency_black , forecast_black,links_black,black_event, black_old_event ] = await black();

  
let currency_hour = black_prev.map((e,index) => {return name_currency_black[index]+' , '+e.slice(8,13)});

let morning_star = [];
let michael = [];
let raphael = [];
let petru = [];
let cactus = [];
let phoenix;
let burn = 0;
let ashes = [];
let arrow = [];
let achilles = [];
for(gabriel = 1; gabriel < black_prev.length;){
  
if(currency_hour[gabriel].includes(':')){
let spear = gabriel;

while(spear <= black_prev.length ){
  if(!ashes.includes(currency_hour[spear])){
    if(currency_hour[gabriel] == currency_hour[spear]){
      morning_star.push(black_prev[spear].slice(8))
      michael.push(black_prev[spear].slice(0,5)+' , '+forecast_black[spear]);
      raphael.push(forecast_black[spear]);
      petru.push(links_black[spear]);
      cactus.push(td_black_prev[spear]);
    }
    else if(burn == 0){ phoenix = spear; burn++ }
  }
spear++
}
ashes.push(currency_hour[gabriel])
//console.log( morning_star); console.log(michael); console.log(raphael); console.log(petru); console.log(cactus);

if(you(michael) == true){
         let sirius;
         let arcturus;
         let pleiades;
         [sirius,arcturus,pleiades,pegasus] = rimuovere_le_mele_marce(morning_star,raphael,petru,cactus);

         let polaris = await check(white_prev , white_old_prev,white_event, white_old_event ,black_prev, black_old_prev,td_black_prev,td_black_old , name_currency_black , forecast_black, links_black, black_event, black_old_event, sirius);
  
         if(!polaris.includes('is just water falling from the sky not lava'))
          { let ra = currency_hour[gabriel];
            let [heal,patroclus] = await titanomachy(ra,pegasus,polaris,arcturus,pleiades);
            arrow.push(heal);
            achilles.push(patroclus); 
           }
                          }      
morning_star = [];
michael = [];
raphael = [];
petru = [];
cactus = [];
burn = 0;
gabriel = phoenix;
                                                }
else {gabriel++}
}

[blue,sky] = rimuovere_le_mele_marce(arrow,achilles);
  
console.log(blue,sky)
return [blue,sky]
}

  
return lucifer()
}
